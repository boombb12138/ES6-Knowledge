### 错误处理方案

封装一个工具函数 想告知外界出现错误 可以通过throw关键字抛出错误信息

```js
function foo() {
    throw new Error('foo error')
}

function test() {
    foo()
}

test()
```

Node会打印出错函数的函数调用栈

如果不处理，那么异常会进一步抛出，直到最顶层的调用

如果在最顶层也没有对这个异常进行处理，那么程序就会终止执行，并且报错

##### 对抛出的错误处理

## JavaScript模块化

####  到底什么是模块化、模块化开发呢？

- 事实上模块化开发最终的目的是将程序划分成一个个小的结构；
- 这个结构中编写属于自己的逻辑代码，有自己的作用域，不会影响到其他的结构；
- 这个结构可以将自己希望暴露的变量、函数、对象等导出给其结构使用；
- 也可以通过某种方式，导入另外结构中的变量、函数、对象等；
- 上面说提到的<u>结构</u>，就是<u>模块</u>；按照这种结构划分开发程序的过程，就是<u>模块化开发</u>的过程；

每一个文件就是一个模块 相互之间不影响 别人访问不了这个文件里的东西，这个文件有自己的作用域

可以用一种方法将数据导出，在另一个文件要用的时候再导入

#### 早期没有模块化规范

为了解决没有作用域导致命名冲突 就把代码写到函数里面 因为函数有自己的作用域 再将该函数转成自执行函数 

将要暴露的变量以对象的键值对的形式返回出去

### CommonJS

#### CommonJS规范和Node

Node是CommonJS的实现

webpack模块化打包工具 可以将es module转化为浏览器支持的模块

在编写webpack的时候用的是CommonJS规范 

![Node中CommonJS原理](E:\工作\产品经理\JavaScript高级\笔记\class_image\Node中CommonJS原理.png)

#### require细节

require是一个函数 可以引入一个文件（模块）导出的对象

##### require的查找规则：

导入格式：require（X）

情况1：X是Node的核心模块

情况2：路径

情况3：导入第三方包

#### 模块的加载过程

#### CommonJS的缺点

浏览器引入main.js main.js中可能引入了abc.js 这个js文件还在服务器 就要等到这个文件下载下来才能执行后续的文件，同步加载模块

在webpack环境中有2个地方用到CommonJS：

1. webpack配置本身
2. 搭建自己的项目（Vue/React）



